<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>autoPose - motion music (ambient)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            padding: 16px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
            justify-content: center;
        }
        .sensitivity-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }
        .sensitivity-control input {
            width: 120px;
            margin: 0;
        }
        #canvas-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        button {
            background: #2c2c2c;
            color: #ffffff;
            border: 1px solid #404040;
            padding: 10px 16px;
            margin: 0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        button:hover {
            background: #3c3c3c;
            border-color: #505050;
        }
        button:active {
            background: #1c1c1c;
        }
        button.success {
            background: #1a472a;
            border-color: #2d6a3e;
            color: #ffffff;
        }
        button.success:hover {
            background: #22543d;
        }
        .debug-info {
            font-size: 11px;
            color: #aaa;
            display: flex;
            gap: 16px;
            margin: 0;
            padding: 0;
            border: none;
        }
        .debug-info span {
            display: inline-block;
            min-width: 20px;
            text-align: right;
        }
        h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            white-space: nowrap;
        }
        h4 {
            margin: 0 0 16px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
        }
        .success-text {
            color: #28a745;
            font-weight: 500;
        }
        #audioStatus {
            margin: 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>autoPose</h3>
        <button id="audioButton" onclick="startAudioContext()">Start Audio</button>
        <button onclick="toggleCamera()">Toggle Camera</button>
        <button onclick="toggleStyleEffect()" id="styleButton">Art: Normal</button>
        <button onclick="toggleMotionVisualization()">Show Motion</button>
        
        <div class="sensitivity-control">
            <label>BPM:</label>
            <input type="range" id="bpmSlider" min="60" max="120" value="90" onchange="updateBPM(this.value)">
            <span id="bpmValue">90</span>
        </div>
        
        <div class="debug-info">
            <div>Motion: <span id="motionLevel">0</span></div>
            <div>Intensity: <span id="drumVolume">0%</span></div>
            <div>Mode: <span id="currentMode">-</span></div>
        </div>
        
        <p id="audioStatus"><small>Move slowly for ambient textures. Faster motion adds rhythmic elements.</small></p>
    </div>

    <div id="canvas-container"></div>

    <script>
        // Global variables
        let video;
        let prevFrame;
        let motionPixels = [];
        let motionThreshold = 30;
        let isCameraOn = false;
        let showMotionVisualization = false;
        
        // Audio setup
        let synths = {};
        let effects = {};
        let isAudioStarted = false;
        let drumLoop = null;
        let masterBPM = 90; // Slower default
        
        // Musical variables
        let currentKeyIndex = 0;
        let targetKeyIndex = 0;
        let keyTransition = 0;
        let measureCount = 0;
        let beatCount = 0;
        
        // Define minor keys and their Dorian relatives
        const keyPairs = [
            {
                minor: { root: 'A', notes: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
                dorian: { root: 'D', notes: ['D', 'E', 'F', 'G', 'A', 'B', 'C'] }
            },
            {
                minor: { root: 'E', notes: ['E', 'F#', 'G', 'A', 'B', 'C', 'D'] },
                dorian: { root: 'A', notes: ['A', 'B', 'C', 'D', 'E', 'F#', 'G'] }
            },
            {
                minor: { root: 'D', notes: ['D', 'E', 'F', 'G', 'A', 'Bb', 'C'] },
                dorian: { root: 'G', notes: ['G', 'A', 'Bb', 'C', 'D', 'E', 'F'] }
            },
            {
                minor: { root: 'B', notes: ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'] },
                dorian: { root: 'E', notes: ['E', 'F#', 'G', 'A', 'B', 'C#', 'D'] }
            }
        ];
        
        let currentMode = 'minor'; // 'minor' or 'dorian'
        let modeTransition = 0;
        
        // Chord progressions for minor and dorian
        const getChordProgression = (keyPair, mode) => {
            if (mode === 'minor') {
                const root = keyPair.minor.root;
                return [
                    {name: 'i', notes: [`${root}3`, `${keyPair.minor.notes[2]}3`, `${keyPair.minor.notes[4]}3`], bass: `${root}2`},
                    {name: 'iv', notes: [`${keyPair.minor.notes[3]}3`, `${keyPair.minor.notes[5]}3`, `${root}4`], bass: `${keyPair.minor.notes[3]}2`},
                    {name: 'v', notes: [`${keyPair.minor.notes[4]}3`, `${keyPair.minor.notes[6]}3`, `${keyPair.minor.notes[1]}4`], bass: `${keyPair.minor.notes[4]}2`},
                    {name: 'VI', notes: [`${keyPair.minor.notes[5]}3`, `${root}4`, `${keyPair.minor.notes[2]}4`], bass: `${keyPair.minor.notes[5]}2`}
                ];
            } else {
                const root = keyPair.dorian.root;
                return [
                    {name: 'i', notes: [`${root}3`, `${keyPair.dorian.notes[2]}3`, `${keyPair.dorian.notes[4]}3`], bass: `${root}2`},
                    {name: 'ii', notes: [`${keyPair.dorian.notes[1]}3`, `${keyPair.dorian.notes[3]}3`, `${keyPair.dorian.notes[5]}3`], bass: `${keyPair.dorian.notes[1]}2`},
                    {name: 'IV', notes: [`${keyPair.dorian.notes[3]}3`, `${keyPair.dorian.notes[5]}3`, `${root}4`], bass: `${keyPair.dorian.notes[3]}2`},
                    {name: 'v', notes: [`${keyPair.dorian.notes[4]}3`, `${keyPair.dorian.notes[6]}3`, `${keyPair.dorian.notes[1]}4`], bass: `${keyPair.dorian.notes[4]}2`}
                ];
            }
        };
        
        // Visual effects
        let artStyles = ['normal', 'blackwhite', 'lineart', 'pixel', 'neon', 'posterize'];
        let currentStyleIndex = 0;
        let particles = [];
        let colorPalette = [
            [100, 120, 180], // Muted blue
            [120, 100, 140], // Muted purple
            [100, 140, 120], // Muted teal
            [140, 120, 100], // Muted brown
            [120, 120, 140], // Muted gray-purple
            [100, 130, 130]  // Muted cyan
        ];
        
        // Motion zones
        let motionZones = {
            upper: { x: 100, y: 0, w: 600, h: 150, motion: 0, active: false, smoothMotion: 0 },
            lower: { x: 100, y: 450, w: 600, h: 150, motion: 0, active: false, smoothMotion: 0 },
            left: { x: 0, y: 150, w: 150, h: 300, motion: 0, active: false, smoothMotion: 0 },
            right: { x: 650, y: 150, w: 150, h: 300, motion: 0, active: false, smoothMotion: 0 },
            center: { x: 250, y: 200, w: 300, h: 200, motion: 0, active: false, smoothMotion: 0 }
        };
        
        // Gesture detection
        let lastTriggerTime = {};
        let audioLevels = {
            harmony: 0,
            drums: 0,
            bass: 0,
            texture: 0,
            lead: 0
        };
        
        // Activity tracking for key changes
        let activityLevel = 0;
        let lastKeyChangeTime = 0;

        function setup() {
            let canvas = createCanvas(800, 600);
            canvas.parent('canvas-container');
            canvas.mousePressed(canvasClicked);
            
            setupAudio();
            
            for (let i = 0; i < 8; i++) { // Fewer particles
                particles.push(new Particle());
            }
            
            prevFrame = createGraphics(width, height);
            updateCurrentMode();
        }

        function canvasClicked() {
            if (!isAudioStarted) {
                console.log('Canvas clicked - attempting to start audio...');
                startAudioContext();
            }
        }

        function setupAudio() {
            // Create audio chain with compression and limiting
            const compressor = new Tone.Compressor({
                threshold: -24,
                ratio: 4,
                attack: 0.003,
                release: 0.1
            }).toDestination();
            
            const limiter = new Tone.Limiter(-3).connect(compressor);
            
            // Ambient pad synth
            synths.harmony = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: {
                    attack: 2,
                    decay: 1,
                    sustain: 0.5,
                    release: 3
                }
            }).connect(limiter);
            
            // Sub bass
            synths.bass = new Tone.MonoSynth({
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.1,
                    decay: 0.3,
                    sustain: 0.4,
                    release: 1
                },
                filter: {
                    Q: 1,
                    frequency: 150,
                    type: "lowpass"
                }
            }).connect(limiter);
            
            // Texture/lead synth
            synths.lead = new Tone.FMSynth({
                harmonicity: 2,
                modulationIndex: 2,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.5,
                    decay: 0.5,
                    sustain: 0.2,
                    release: 2
                }
            }).connect(limiter);
            
            // Ambient texture generator
            synths.texture = new Tone.AMSynth({
                harmonicity: 3,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 3,
                    decay: 2,
                    sustain: 0.3,
                    release: 5
                }
            }).connect(limiter);
            
            // Minimal percussion
            synths.kick = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 10,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 1.4
                }
            }).connect(limiter);
            
            synths.hihat = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001,
                    decay: 0.03,
                    sustain: 0,
                    release: 0.03
                }
            }).connect(limiter);
            
            // Set very low initial volumes
            synths.harmony.volume.value = -20;
            synths.bass.volume.value = -18;
            synths.lead.volume.value = -22;
            synths.texture.volume.value = -24;
            synths.kick.volume.value = -60;
            synths.hihat.volume.value = -60;
            
            // Ambient effects
            effects.reverb = new Tone.Reverb({
                decay: 5,
                wet: 0.4
            }).connect(limiter);
            
            effects.delay = new Tone.FeedbackDelay({
                delayTime: "4n.",
                feedback: 0.2,
                wet: 0.15
            }).connect(limiter);
            
            effects.chorus = new Tone.Chorus({
                frequency: 0.5,
                delayTime: 5,
                depth: 0.3,
                wet: 0.2
            }).connect(limiter);
            
            // Connect synths to effects
            synths.harmony.connect(effects.reverb);
            synths.harmony.connect(effects.chorus);
            synths.lead.connect(effects.delay);
            synths.texture.connect(effects.reverb);
            
            // Set up master tempo
            Tone.Transport.bpm.value = masterBPM;
            
            // Minimal drum loop
            drumLoop = new Tone.Loop((time) => {
                beatCount = (beatCount + 1) % 16;
                if (beatCount === 0) {
                    measureCount++;
                    
                    // Check for mode/key changes every 8 measures
                    if (measureCount % 8 === 0) {
                        checkForModeChange();
                    }
                    
                    if (measureCount % 16 === 0) {
                        checkForKeyChange();
                    }
                }
                
                // Very minimal drum pattern - only when there's significant motion
                let totalMotion = Object.values(motionZones).reduce((sum, zone) => sum + zone.smoothMotion, 0);
                
                if (totalMotion > 0.2) {
                    if (beatCount === 0) {
                        synths.kick.triggerAttackRelease("C1", "8n", time, 0.3);
                    }
                    
                    if (beatCount === 8 && totalMotion > 0.4) {
                        synths.kick.triggerAttackRelease("C1", "8n", time, 0.2);
                    }
                    
                    if ((beatCount === 4 || beatCount === 12) && totalMotion > 0.6) {
                        synths.hihat.triggerAttackRelease("32n", time, 0.1);
                    }
                }
            }, "16n");
        }

        function updateCurrentMode() {
            const keyPair = keyPairs[Math.floor(currentKeyIndex)];
            const modeName = currentMode === 'minor' ? `${keyPair.minor.root}m` : `${keyPair.dorian.root} Dorian`;
            document.getElementById('currentMode').textContent = modeName;
        }

        function checkForModeChange() {
            // Change between minor and dorian based on activity
            if (activityLevel > 0.5 && currentMode === 'minor') {
                currentMode = 'dorian';
                updateCurrentMode();
            } else if (activityLevel < 0.3 && currentMode === 'dorian') {
                currentMode = 'minor';
                updateCurrentMode();
            }
        }

        function checkForKeyChange() {
            const currentTime = millis();
            if (currentTime - lastKeyChangeTime > 30000) { // At least 30 seconds between changes
                // Choose next key based on circle of fifths or relative keys
                targetKeyIndex = (currentKeyIndex + 1) % keyPairs.length;
                lastKeyChangeTime = currentTime;
            }
        }

        async function startAudioContext() {
            try {
                console.log('Attempting to start audio context...');
                document.getElementById('audioButton').textContent = 'Starting Audio...';
                document.getElementById('audioButton').disabled = true;
                
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log('Tone.js started successfully');
                }
                
                await testAudio();
                
                isAudioStarted = true;
                drumLoop.start(0);
                Tone.Transport.start();
                document.getElementById('audioButton').textContent = 'Audio Ready';
                document.getElementById('audioButton').className = 'success';
                document.getElementById('audioStatus').innerHTML = '<strong class="success-text">Audio Ready! Enable camera for motion-controlled ambience.</strong>';
                console.log('Audio context started - move slowly for ambient textures!');
                
            } catch (error) {
                console.error('Error starting audio:', error);
                document.getElementById('audioButton').textContent = 'Audio Failed - Try Again';
                document.getElementById('audioButton').disabled = false;
                document.getElementById('audioButton').style.background = '#dc3545';
            }
        }
        
        async function testAudio() {
            try {
                const testSynth = new Tone.Oscillator(440, "sine").toDestination();
                testSynth.volume.value = -40;
                testSynth.start();
                testSynth.stop("+0.1");
                console.log('Audio test successful');
            } catch (error) {
                console.error('Audio test failed:', error);
                throw error;
            }
        }

        function toggleCamera() {
            if (!isCameraOn) {
                video = createCapture(VIDEO);
                video.size(width, height);
                video.hide();
                isCameraOn = true;
                console.log('Camera started');
            } else {
                if (video) {
                    video.remove();
                    video = null;
                }
                isCameraOn = false;
                console.log('Camera stopped');
            }
        }

        function toggleStyleEffect() {
            currentStyleIndex = (currentStyleIndex + 1) % artStyles.length;
            let styleName = artStyles[currentStyleIndex];
            let displayName = styleName.charAt(0).toUpperCase() + styleName.slice(1);
            document.getElementById('styleButton').textContent = 'Art: ' + displayName;
        }

        function toggleMotionVisualization() {
            showMotionVisualization = !showMotionVisualization;
        }

        function updateBPM(value) {
            masterBPM = value;
            Tone.Transport.bpm.value = masterBPM;
            document.getElementById('bpmValue').textContent = value;
        }

        function draw() {
            let currentStyle = artStyles[currentStyleIndex];
            
            // Set background based on style
            if (currentStyle === 'lineart' || currentStyle === 'blackwhite') {
                background(255);
            } else if (currentStyle === 'neon') {
                background(0, 0, 20);
            } else {
                background(20);
            }
            
            if (video && isCameraOn) {
                push();
                scale(-1, 1);
                
                // Apply different art styles
                switch(currentStyle) {
                    case 'normal':
                        image(video, -width, 0, width, height);
                        break;
                    case 'blackwhite':
                        applyBlackWhiteEffect();
                        break;
                    case 'lineart':
                        applyLineArtEffect();
                        break;
                    case 'pixel':
                        applyPixelEffect();
                        break;
                    case 'neon':
                        applyNeonEffect();
                        break;
                    case 'posterize':
                        applyPosterizeEffect();
                        break;
                }
                
                pop();
                
                detectMotion();
                processMotionGestures();
            } else {
                push();
                fill(100);
                textAlign(CENTER);
                textSize(20);
                if (!isAudioStarted) {
                    text('Click anywhere or press "Start Audio" button', width/2, height/2 - 20);
                    text('to begin!', width/2, height/2 + 20);
                } else {
                    text('Click "Toggle Camera" to start webcam', width/2, height/2);
                }
                pop();
            }
            
            if (showMotionVisualization && motionPixels.length > 0) {
                drawMotionVisualization();
            }
            
            drawMotionZones();
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].display();
                
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }
            
            drawAudioVisualization();
            
            // Fade audio levels
            Object.keys(audioLevels).forEach(key => {
                audioLevels[key] *= 0.95;
            });
            
            // Smooth key transitions
            if (Math.abs(targetKeyIndex - currentKeyIndex) > 0.01) {
                currentKeyIndex += (targetKeyIndex - currentKeyIndex) * 0.02;
                updateCurrentMode();
            }
            
            // Update activity level
            let totalMotion = Object.values(motionZones).reduce((sum, zone) => sum + zone.motion, 0);
            activityLevel = activityLevel * 0.95 + (totalMotion / 50000) * 0.05;
            
            updateDebugInfo();
        }

        function applyBlackWhiteEffect() {
            video.loadPixels();
            for (let x = 0; x < video.width; x += 2) {
                for (let y = 0; y < video.height; y += 2) {
                    let index = (x + y * video.width) * 4;
                    let r = video.pixels[index];
                    let g = video.pixels[index + 1];
                    let b = video.pixels[index + 2];
                    
                    let gray = (r + g + b) / 3;
                    let bw = gray > 120 ? 255 : 0;
                    
                    fill(bw);
                    noStroke();
                    let canvasX = map(x, 0, video.width, -width, 0);
                    let canvasY = map(y, 0, video.height, 0, height);
                    rect(canvasX, canvasY, 4, 4);
                }
            }
        }

        function applyLineArtEffect() {
            video.loadPixels();
            stroke(0);
            strokeWeight(1);
            noFill();
            
            for (let x = 2; x < video.width - 2; x += 3) {
                for (let y = 2; y < video.height - 2; y += 3) {
                    let index = (x + y * video.width) * 4;
                    let r = video.pixels[index];
                    let g = video.pixels[index + 1];
                    let b = video.pixels[index + 2];
                    let brightness = (r + g + b) / 3;
                    
                    let rightIndex = ((x + 1) + y * video.width) * 4;
                    let downIndex = (x + (y + 1) * video.width) * 4;
                    
                    let rightBrightness = (video.pixels[rightIndex] + video.pixels[rightIndex + 1] + video.pixels[rightIndex + 2]) / 3;
                    let downBrightness = (video.pixels[downIndex] + video.pixels[downIndex + 1] + video.pixels[downIndex + 2]) / 3;
                    
                    let edgeStrength = abs(brightness - rightBrightness) + abs(brightness - downBrightness);
                    
                    if (edgeStrength > 30) {
                        let canvasX = map(x, 0, video.width, -width, 0);
                        let canvasY = map(y, 0, video.height, 0, height);
                        point(canvasX, canvasY);
                    }
                }
            }
        }

        function applyPixelEffect() {
            video.loadPixels();
            let pixelSize = 8;
            
            for (let x = 0; x < video.width; x += pixelSize) {
                for (let y = 0; y < video.height; y += pixelSize) {
                    let index = (x + y * video.width) * 4;
                    let r = video.pixels[index];
                    let g = video.pixels[index + 1];
                    let b = video.pixels[index + 2];
                    
                    fill(r, g, b);
                    noStroke();
                    let canvasX = map(x, 0, video.width, -width, 0);
                    let canvasY = map(y, 0, video.height, 0, height);
                    rect(canvasX, canvasY, pixelSize * 2, pixelSize * 2);
                }
            }
        }

        function applyNeonEffect() {
            video.loadPixels();
            blendMode(ADD);
            
            for (let x = 0; x < video.width; x += 4) {
                for (let y = 0; y < video.height; y += 4) {
                    let index = (x + y * video.width) * 4;
                    let r = video.pixels[index];
                    let g = video.pixels[index + 1];
                    let b = video.pixels[index + 2];
                    
                    if (r > 100) r = 255;
                    if (g > 100) g = 255;
                    if (b > 100) b = 255;
                    
                    if (r > 50 || g > 50 || b > 50) {
                        fill(r, g, b, 150);
                        noStroke();
                        let canvasX = map(x, 0, video.width, -width, 0);
                        let canvasY = map(y, 0, video.height, 0, height);
                        ellipse(canvasX, canvasY, 8, 8);
                    }
                }
            }
            blendMode(BLEND);
        }

        function applyPosterizeEffect() {
            video.loadPixels();
            
            for (let x = 0; x < video.width; x += 2) {
                for (let y = 0; y < video.height; y += 2) {
                    let index = (x + y * video.width) * 4;
                    let r = video.pixels[index];
                    let g = video.pixels[index + 1];
                    let b = video.pixels[index + 2];
                    
                    r = Math.floor(r / 64) * 64;
                    g = Math.floor(g / 64) * 64;
                    b = Math.floor(b / 64) * 64;
                    
                    fill(r, g, b);
                    noStroke();
                    let canvasX = map(x, 0, video.width, -width, 0);
                    let canvasY = map(y, 0, video.height, 0, height);
                    rect(canvasX, canvasY, 3, 3);
                }
            }
        }

        function detectMotion() {
            if (!video) return;
            
            video.loadPixels();
            prevFrame.loadPixels();
            
            let totalMotion = 0;
            motionPixels = [];
            
            Object.keys(motionZones).forEach(key => {
                motionZones[key].motion = 0;
                motionZones[key].active = false;
            });
            
            for (let x = 0; x < video.width; x += 4) {
                for (let y = 0; y < video.height; y += 4) {
                    let index = (x + y * video.width) * 4;
                    
                    let rCurrent = video.pixels[index];
                    let gCurrent = video.pixels[index + 1];
                    let bCurrent = video.pixels[index + 2];
                    
                    let rPrev = prevFrame.pixels[index] || 0;
                    let gPrev = prevFrame.pixels[index + 1] || 0;
                    let bPrev = prevFrame.pixels[index + 2] || 0;
                    
                    let diff = abs(rCurrent - rPrev) + abs(gCurrent - gPrev) + abs(bCurrent - bPrev);
                    
                    if (diff > motionThreshold) {
                        totalMotion += diff;
                        motionPixels.push({x: x, y: y, intensity: diff});
                        
                        let canvasX = map(x, 0, video.width, width, 0);
                        let canvasY = map(y, 0, video.height, 0, height);
                        
                        Object.keys(motionZones).forEach(zoneKey => {
                            let zone = motionZones[zoneKey];
                            if (canvasX >= zone.x && canvasX <= zone.x + zone.w &&
                                canvasY >= zone.y && canvasY <= zone.y + zone.h) {
                                zone.motion += diff;
                            }
                        });
                    }
                }
            }
            
            // Smooth motion values
            Object.keys(motionZones).forEach(key => {
                motionZones[key].smoothMotion = motionZones[key].smoothMotion * 0.8 + (motionZones[key].motion / 10000) * 0.2;
                motionZones[key].active = motionZones[key].smoothMotion > 0.15;
            });
            
            prevFrame.image(video, 0, 0);
        }

        function processMotionGestures() {
            if (!isAudioStarted) return;
            
            // Overall motion affects drum presence and filter
            let centerMotion = motionZones.center.smoothMotion;
            let intensityPercent = Math.round(Math.min(centerMotion * 100, 100));
            
            // Very subtle drum volume control
            let drumVolumeDB = centerMotion > 0.1 ? 
                -40 + (centerMotion * 20) : // Max -20dB
                -60;
            
            synths.kick.volume.rampTo(drumVolumeDB, 0.5);
            synths.hihat.volume.rampTo(drumVolumeDB - 10, 0.5);
            
            document.getElementById('drumVolume').textContent = intensityPercent + '%';
            
            let currentTime = millis();
            
            // Less frequent triggering
            let harmonyInterval = 3000 - (activityLevel * 1500); // 1.5-3 seconds
            let bassInterval = 4000 - (activityLevel * 2000); // 2-4 seconds
            let textureInterval = 5000 - (activityLevel * 2000); // 3-5 seconds
            
            // Get current chord progression
            const keyPair = keyPairs[Math.floor(currentKeyIndex)];
            const progression = getChordProgression(keyPair, currentMode);
            const currentChord = progression[measureCount % 4];
            
            // Upper zone - harmony
            if (motionZones.upper.smoothMotion > 0.1 && 
                (!lastTriggerTime.harmony || currentTime - lastTriggerTime.harmony > harmonyInterval)) {
                triggerHarmony(currentChord);
                lastTriggerTime.harmony = currentTime;
            }
            
            // Lower zone - bass
            if (motionZones.lower.smoothMotion > 0.1 && 
                (!lastTriggerTime.bass || currentTime - lastTriggerTime.bass > bassInterval)) {
                triggerBass(currentChord);
                lastTriggerTime.bass = currentTime;
            }
            
            // Side zones - textures
            if ((motionZones.left.smoothMotion > 0.1 || motionZones.right.smoothMotion > 0.1) && 
                (!lastTriggerTime.texture || currentTime - lastTriggerTime.texture > textureInterval)) {
                triggerTexture(keyPair, currentMode);
                lastTriggerTime.texture = currentTime;
            }
            
            // Center intense motion - lead notes
            if (motionZones.center.smoothMotion > 0.3 && 
                (!lastTriggerTime.lead || currentTime - lastTriggerTime.lead > 2000)) {
                triggerLead(keyPair, currentMode);
                lastTriggerTime.lead = currentTime;
            }
        }

        function triggerHarmony(chord) {
            try {
                // Add ambient voicings
                let voicing = [...chord.notes];
                if (random() > 0.6) {
                    // Add 9th
                    let ninth = Tone.Frequency(voicing[0]).transpose(14).toNote();
                    voicing.push(ninth);
                }
                
                let velocity = 0.2 + (motionZones.upper.smoothMotion * 0.3);
                synths.harmony.triggerAttackRelease(voicing, '2m', '+4n', velocity);
                
                audioLevels.harmony = 1;
                
                for (let i = 0; i < 2; i++) {
                    particles.push(new HarmonyParticle());
                }
            } catch (error) {
                console.error('Error in triggerHarmony:', error);
            }
        }

        function triggerBass(chord) {
            try {
                let bassNote = chord.bass;
                let velocity = 0.3 + (motionZones.lower.smoothMotion * 0.3);
                
                synths.bass.triggerAttackRelease(bassNote, '1m', '+8n', velocity);
                
                audioLevels.bass = 1;
                
                particles.push(new BassParticle());
            } catch (error) {
                console.error('Error in triggerBass:', error);
            }
        }

        function triggerTexture(keyPair, mode) {
            try {
                const scale = mode === 'minor' ? keyPair.minor.notes : keyPair.dorian.notes;
                const octave = random([4, 5]);
                const note = random(scale) + octave;
                
                let velocity = 0.2 + (random() * 0.2);
                synths.texture.triggerAttackRelease(note, '4m', '+2n', velocity);
                
                audioLevels.texture = 1;
                
                for (let i = 0; i < 3; i++) {
                    particles.push(new TextureParticle());
                }
            } catch (error) {
                console.error('Error in triggerTexture:', error);
            }
        }

        function triggerLead(keyPair, mode) {
            try {
                const scale = mode === 'minor' ? keyPair.minor.notes : keyPair.dorian.notes;
                const octave = random([5, 6]);
                
                // Simple melodic fragment
                let note1 = random(scale) + octave;
                let note2 = random(scale) + octave;
                
                let velocity = 0.15 + (motionZones.center.smoothMotion * 0.2);
                
                synths.lead.triggerAttackRelease(note1, '4n', '+0', velocity);
                synths.lead.triggerAttackRelease(note2, '4n', '+4n', velocity * 0.8);
                
                audioLevels.lead = 1;
                
                for (let i = 0; i < 4; i++) {
                    particles.push(new LeadParticle());
                }
            } catch (error) {
                console.error('Error in triggerLead:', error);
            }
        }

        function updateDebugInfo() {
            let totalMotion = Object.values(motionZones).reduce((sum, zone) => sum + zone.motion, 0);
            document.getElementById('motionLevel').textContent = Math.round(totalMotion / 100);
        }

        function drawMotionVisualization() {
            push();
            for (let motion of motionPixels) {
                let canvasX = map(motion.x, 0, video.width, width, 0);
                let canvasY = map(motion.y, 0, video.height, 0, height);
                
                fill(150, 100, 200, map(motion.intensity, motionThreshold, 255, 30, 150));
                noStroke();
                ellipse(canvasX, canvasY, 3, 3);
            }
            pop();
        }

        function drawMotionZones() {
            push();
            noFill();
            
            Object.keys(motionZones).forEach(key => {
                let zone = motionZones[key];
                let alpha = zone.smoothMotion * 255;
                
                if (zone.active) {
                    stroke(100, 150, 200, alpha);
                    strokeWeight(2);
                } else {
                    stroke(80, 80, 100, alpha * 0.3);
                    strokeWeight(1);
                }
                rect(zone.x, zone.y, zone.w, zone.h, 10);
            });
            pop();
        }

        function drawAudioVisualization() {
            push();
            blendMode(ADD);
            
            if (audioLevels.harmony > 0.1) {
                fill(100, 120, 180, audioLevels.harmony * 60);
                noStroke();
                ellipse(width/2, height/3, audioLevels.harmony * 300, audioLevels.harmony * 200);
            }
            
            if (audioLevels.bass > 0.1) {
                fill(120, 100, 140, audioLevels.bass * 40);
                ellipse(width/2, height * 0.8, audioLevels.bass * 400, audioLevels.bass * 100);
            }
            
            if (audioLevels.texture > 0.1) {
                fill(100, 140, 120, audioLevels.texture * 50);
                for (let i = 0; i < 5; i++) {
                    let x = width * (0.2 + i * 0.15);
                    let y = height/2 + sin(frameCount * 0.02 + i) * audioLevels.texture * 50;
                    ellipse(x, y, audioLevels.texture * 30, audioLevels.texture * 30);
                }
            }
            
            if (audioLevels.lead > 0.1) {
                stroke(140, 120, 100, audioLevels.lead * 100);
                strokeWeight(1);
                noFill();
                for (let i = 0; i < 10; i++) {
                    let angle = frameCount * 0.01 + i * 0.6;
                    let r = audioLevels.lead * 100 + i * 10;
                    let x = width/2 + cos(angle) * r;
                    let y = height/2 + sin(angle) * r;
                    line(width/2, height/2, x, y);
                }
            }
            
            pop();
        }

        // Particle classes
        class Particle {
            constructor() {
                this.x = random(width);
                this.y = random(height);
                this.vx = random(-0.2, 0.2);
                this.vy = random(-0.2, 0.2);
                this.life = 255;
                this.color = random(colorPalette);
                this.size = random(1, 3);
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.5;
                
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
            }
            
            display() {
                push();
                fill(this.color[0], this.color[1], this.color[2], this.life * 0.5);
                noStroke();
                ellipse(this.x, this.y, this.size, this.size);
                pop();
            }
            
            isDead() {
                return this.life <= 0;
            }
        }

        class HarmonyParticle extends Particle {
            constructor() {
                super();
                this.x = width/2 + random(-100, 100);
                this.y = height/3;
                this.vx = random(-0.5, 0.5);
                this.vy = random(-0.3, 0.1);
                this.color = [100, 120, 180];
                this.size = random(3, 6);
            }
            
            update() {
                super.update();
                this.size *= 1.005;
            }
        }

        class BassParticle extends Particle {
            constructor() {
                super();
                this.x = width/2;
                this.y = height * 0.8;
                this.vx = random(-1, 1);
                this.vy = random(-0.5, -1);
                this.color = [120, 100, 140];
                this.size = random(5, 10);
            }
            
            update() {
                super.update();
                this.vy += 0.05; // Gravity
            }
        }

        class TextureParticle extends Particle {
            constructor() {
                super();
                this.x = random() > 0.5 ? 0 : width;
                this.y = random(height);
                this.vx = this.x === 0 ? random(0.5, 1) : random(-1, -0.5);
                this.vy = random(-0.5, 0.5);
                this.color = [100, 140, 120];
                this.twinkle = random(TWO_PI);
            }
            
            update() {
                super.update();
                this.twinkle += 0.05;
            }
            
            display() {
                push();
                let alpha = (sin(this.twinkle) + 1) * 0.25 * this.life;
                fill(this.color[0], this.color[1], this.color[2], alpha);
                noStroke();
                ellipse(this.x, this.y, this.size * 2, this.size * 2);
                pop();
            }
        }

        class LeadParticle extends Particle {
            constructor() {
                super();
                this.x = width/2 + random(-50, 50);
                this.y = height/2 + random(-50, 50);
                this.angle = random(TWO_PI);
                this.radius = 0;
                this.color = [140, 120, 100];
            }
            
            update() {
                this.radius += 1;
                this.x = width/2 + cos(this.angle) * this.radius;
                this.y = height/2 + sin(this.angle) * this.radius;
                this.life -= 2;
            }
            
            display() {
                push();
                stroke(this.color[0], this.color[1], this.color[2], this.life * 0.5);
                strokeWeight(1);
                noFill();
                let size = this.radius * 0.1;
                ellipse(this.x, this.y, size, size);
                pop();
            }
        }
    </script>
</body>
</html>
